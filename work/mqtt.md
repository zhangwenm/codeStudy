# mqtt入门
- 亿级（5000w发，5000w收，一对一链接）20复制节点，3主节点（写）。机器（64c，120g）
- Replicant 节点会接受全部的客户端请求，所以 Replicant 节点需要的资源会更高一些
## 节点角色
- 核心节点作为数据库的真数据源：它们以全网状连接，每一个节点都包含一个最新的数据副本。 核心节点一般是静态和持久的，也就是说，不建议对核心集群进行自动伸缩
- 复制节点，将所有表的写操作转到核心节点上处理。 它们各自连接到核心节点的其中一个，并被动地复制核心节点的事务。 这意味着复制节点不允许自己执行任何写操作。  
相反，它们要求核心节点代表它们更新数据。 同时，它们有一个完整的本地数据副本，所以读取访问的速度也同样快。
## 概览
- MQTT 是一种基于发布/订阅模式的轻量级消息传输协议
- 专门针对低带宽和不稳定网络环境的物联网应用而设计
- mqtt特点
  - 简单容易实现
  - 支持 QoS（设备网络环境复杂）
  - 轻量且省带宽（因为那时候带宽很贵）
  - 数据无关（不关心 Payload 数据格式）
  - 有持续地会话感知能力（时刻知道设备是否在线）
- mqtt为适用物联网的最佳协议
  - 轻量高效，节省带宽。
    - 将协议本身占用的额外消耗最小化，消息头部最小只需两字节。占用硬件资源少，可运行各种边缘设备
  - 可靠消息传递。[QOS](https://www.emqx.com/zh/blog/introduction-to-mqtt-qos).qos由发布者制定，订阅者沿用。  
  也有一些情况会根据订阅者的要求，qos在转发的时候进行降级
    - qos0：消息最对传递一次。投递的效率较高，可能会丢失数据，错过断开期间的消息。QoS 0 传输一些高频且不那么重要的数据，  
    比如传感器数据，周期性更新，即使遗漏几个周期的数据也可以接受。
    - qos1：消息传递至少一次。适合传输一些较为重要的数据，比如下达关键指令、更新重要的有实时性要求的状态等。但需要考虑消息  
    重复带来的影响
    - qos2：消息仅传递一次。既可以保证消息到达，也可以保证消息不会重复，但传输成本最高。我们会在金融、航空等行业场景下会更  
    多地见到 QoS 2 的使用。
  - 支持海量链接
    - 最近发布的 EMQX 5.0 通过一个 23 节点的集群达成了 1 亿 MQTT 连接+每秒 100 万消息吞吐，这使得 EMQX 5.0 成为目前  
    为止全球最具扩展性的 MQTT 服务器。
  - 安全的双向通信
    - 依赖于发布订阅模式，发布者与订阅者不需要建立直接连接，也不需要同时在线，而是由消息服务器负责所有消息的路由和分发工作。
  - 在线状态感知
    - MQTT 提供了心跳保活（Keep Alive）机制。在客户端与服务端长时间无消息交互的情况下，Keep Alive 保持连接不被断开，若  
    一旦断开，客户端可即时感知并立即重连。
    - MQTT 设计了遗愿（Last Will） 消息，让服务端在发现客户端异常下线的情况下，帮助客户端发布一条遗愿消息到指定的 MQTT 主题。
    - 部分 MQTT 服务器如 EMQX 也提供了上下线事件通知功能，当后端服务订阅了特定主题后，即可收到所有客户端的上下线事件，这样有助于  
    后端服务统一处理客户端的上下线事件。
  - MQTT 5.0 与 3.1.1
    - MQTT 5.0 在 3.1.1 版本基础上增加了会话/消息延时、原因码、主题别名、用户属性、共享订阅等更加符合现代物联网应用需求的特性，  
    提高了大型系统的性能、稳定性与可扩展性
  - MQTT 服务器
    - MQTT 服务器负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。一个成熟的 MQTT 服务器可支持海量  
    的客户端连接及百万级的消息吞吐，帮助物联网业务提供商专注于业务功能并快速创建一个可靠的 MQTT 应用。
  - MQTT 客户端
    - 任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端
    - 客户端与服务器建立网络连接后，需要先发送一个 CONNECT 数据包给服务器。服务器收到 CONNECT回复一个 CONNACK 给客户端，客户端收到  
    CONNACK 包后表示 MQTT 连接建立成功。如果客户端在超时时间内未收到服务器的 CONNACK 数据包，就会主动关闭连接。
## 重要参数
- keep alive机制
  - 客户端在创建和 MQTT Broker 的连接时，只要将连接请求协议包内的 Keep Alive 可变头部字段设置为非 0 值，就可以在通信双方间启用  
  Keep Alive 机制
  - Keep Alive 为 0~65535 的一个整数，代表客户端发送两次 MQTT 协议包之间的最大间隔时间
  - Broker 在收到客户端的连接请求后，会检查可变头部中的 Keep Alive 字段的值，如果有值，则 Broker 将会启用 Keep Alive 机制
    - 客户端流程：任意两次mqtt协议包间隔不超过keep alive的值。如果客户端空闲无包发送，则发送PINGREQ 协议包。broker收到PINGREQ  
    包后，需要回复PINGRESP包，如果客户端在一个可靠的时间内，没有收到服务器的 PINGRESP 协议包，则说明当前存在半连接、或者 Broker   
    已经下线、或者出现了网络故障，这个时候，客户端应当关闭当前连接。
    - broker流程：在连接建立后，Broker 如果没有在 Keep Alive 的 1.5 倍时间内，收到来自客户端的任何包，则会认为和客户端之间的连  
    接出现了问题，此时 Broker 便会断开和客户端的连接
    - 客户端接管机制：当 Broker 里存在半连接时，如果对应的客户端发起了重连或新的连接，则 Broker 会启动客户端接管机制：关闭旧的半连  
    接，然后与客户端建立新的连接。保证了客户端不会因为 Broker 里存在的半连接，导致无法进行重连
  - 用户可以通过配置来自定义 Keep Alive 机制的行为
    - zone.${zoneName}.server_keepalive。server_keepalive 类型 默认值   整型 无
    - 如果没有设置这个值，则 EMQX 会按照客户端创建连接时的 Keep Alive 的值，来控制 Keep Alive 的行为
    - 如果设置了这个值，则 Broker 会对该 zone 下面所有的连接，强制启用 Keep Alive 机制，并且会使用这个值，覆盖客户端连接请求中的值
    - zone.${zoneName}.keepalive_backoff。keepalive_backoff 类型 默认值   浮点数 0.75
    - MQTT 协议中要求 Broker 在 1.5 倍 Keep Alive 时间内，如果没有收到客户端的任何协议包，则认定客户端断开了连接。
    - 而在 EMQX 中，我们引入了退让系数(keepalive backoff)，并将这个系数通过配置暴露出来，方便用户更灵活的控制 Broker 端的 Keep Alive 行为。
    - 在引入退让系数后，EMQX 通过下面的公式来计算最大超时时间:Keepalive * backoff * 2
- 遗嘱消息
  - 为了是那些意外断线的设备提供的能够优雅将遗嘱发送给第三方的能力，
    - 因网络故障或网络波动，设备在保持连接周期内未能通讯，连接被服务端关闭
    - 设备意外掉电
    - 设备尝试进行不被允许的操作而被服务端关闭连接，例如订阅自身权限以外的主题等
  - Will Retain
    - 它是保留消息与遗嘱消息的结合。如果订阅该遗嘱主题（Will Topic）的客户端不能保证遗嘱消息发布时在线，那么建议为遗嘱消息设置 Will Retain，  
    避免订阅端错过遗嘱消息
  - Will Properties 
    - MQTT 5.0 的一个新特性，不同类型的报文有着不同的属性，例如 CONNECT 报文有会话过期间隔（Session Expiry Interval）、最大报文长度  
    （Maximum Packet Size）等属性，SUBSCRIBE 报文则有订阅标识符（Subscription Identifier）等属性
    - Will Properties 中的消息过期间隔（Message Expiry Interval）等属性与 PUBLISH 报文中的用法基本一致，只有一个遗嘱延迟间隔（Will   
    Delay Interval）是遗嘱消息特有的属性。
    - 遗嘱延迟间隔是遗嘱消息特有，连接断开后延迟一段时间才发布遗嘱消息。避免在设备因网络波动短暂断开连接，但能够快速恢复连接继续提供服务时发出遗嘱消息，并对遗嘱消息订阅方造成困扰
    - 具体延迟多久发布遗嘱消息，除了遗嘱延迟间隔，还受限于会话过期间隔。会话过期间隔设置为 0 时，即会话在网络连接关闭时过期，那么不管遗嘱延迟间隔的值是多少，遗嘱消息都会在网络连接断开时立即发布
- 保留消息
  - 服务端收到 Retain 标志为 1 的 PUBLISH 报文时，除转发外还会在服务端保留一份。每个主题下只保留一份
  - 即便发布这个保留消息的会话终结，保留消息也不会被删除
    - 客户端往某个主题发送一个 Payload 为空的保留消息，服务端就会删除这个主题下的保留消息
    - 如果包含保留消息的 PUBLISH 报文设置了消息过期间隔属性，那么保留消息在服务端存储超过过期时间后就会被删除
  - EMQX MQTT Broker 的保留消息功能是由 emqx_retainer 插件实现，该插件默认开启
  - 插件的配置路径为 etc/plugins/emqx_retainer.conf
  - retainer.storage_type
    - 保留消息的储存位置。仅储存在硬盘中，或是同时储存在内存和硬盘中，可以由用户的业务特点灵活决定。
  - retainer.max_retained_messages、retainer.max_payload_size
    - retainer.max_retained_messages可以储存的保留消息的最大数量，0 表示没有限制。消息数量超出最大值限制后，可以替换已存在的保留消息，但不能为新的主题储存保留消息。
    - retainer.max_payload_size EMQX Broker 可以接收的保留消息的最大 Payload 值。超过最大值时消息服务器会把收到的保留消息作为普通消息处理，不再储存此消息
    - retainer.expiry_interval保留消息的过期时间，0 表示永不过期。如果 PUBLISH 报文中设置了消息过期间隔，那么以 PUBLISH 报文中的消息过期间隔为准。当保留消息的过期后，EMQX Broker 会删除掉此消息
- 消息过期间隔
  - PUBLISH 报文可以设置消息过期间隔。过期间隔是一个四字节的整数，表示应用消息的生命周期，单位是秒。
  - 如果 PUBLISH 报文不设置消息过期间隔，那么应用消息不会过期。
  - 如果 PUBLISH 报文设置了消息过期间隔，并且消息过期将已经过期，服务端还没开始向匹配的订阅者交付该消息，那么服务端必须删除该消息
- 订阅标识符。订阅选项设置[订阅标识符](https://www.emqx.com/zh/blog/subscription-identifier-and-subscription-options)
## 配置参数集 [参数配置](https://www.emqx.io/docs/zh/v4.3/configuration/configuration.html#zoneexternal)
## 主题（Topic）MQTT 主题不需要提前创建，MQTT 客户端在订阅或发布时即自动的创建了主题，开发者无需再关心主题的创建，并且也不需要手动删除主题
- 主题长度层级
  - 建议主题层级为 7 个以内。使用较短的主题名称和较少的主题层级意味着较少的资源消耗
  - Topic层级过多可能导致订阅时的性能问题
- 服务器对主题数量限制
  - 目前 EMQX 的默认配置对主题数量没有限制，但是主题数量越多将会消耗越多的服务器内存
  - 建议一个客户端订阅的主题数量最好控制在 10 个以内
- 通配符主题订阅与普通主题订阅性能
  - 通配符主题订阅的性能弱于普通主题订阅，且会消耗更多的服务器资源
- MQTT 主题通配符。配符只能用于订阅，不能用于发布。
  - +：单层通配。表示通配一个层级，例如 a/+ 匹配 a/x， a/y
  - #：多层通配。表示通配多个层级，例如 a/# 匹配 a/x，a/b/c/d
  - 以 $SYS/ 开头的主题为系统主题
- 共享订阅 带群组，不带群组
  - MQTT 5.0 规定的共享订阅主题以 $share 开头
  - 共享订阅是在多个订阅者之间实现负载均衡的订阅方式
- 带群组的共享订阅
  - 以 $share/<group-name> 为前缀的共享订阅是带群组的共享订阅
  - 属于同一个群组内部的订阅者将以负载均衡接收消息，但 EMQX 会向不同群组广播消息
- 策略可以在全局或每组中指定。
  - 全局策略可以在 broker.shared_subscription_strategy 配置中设置。
  - 配置 broker.shared_subscription_group.$group_name.strategy 为每组策略。
  - random，round_robin（按照订阅顺序），sticky（一直发往上次选取的订阅者），hash
- MQTT 主题使用建议
  - 不建议使用 # 订阅所有主题；
  - 不建议主题以 / 开头或结尾，例如 /chat 或 chat/；
  - 不建议在主题里添加空格及非 ASCII 特殊字符；
  - 同一主题层级内建议使用下划线 _ 或横杆 - 连接单词（或者使用驼峰命名）；
  - 尽量使用较少的主题层级；
  - 当使用通配符时，将唯一值的主题层（例如设备号）越靠近第一层越好。例如，device/00000001/command/# 比device/command/00000001/# 更好。
## MQTT 连接参数的使用
- 基于 TCP 的 MQTT 连接
  - mqtt 是普通的 TCP 连接，端口一般为 1883。
  - mqtts 是基于 TLS/SSL 的安全连接，端口一般为 8883。
  - mqtt://broker.emqx.io:1883 是一个基于普通 TCP 的 MQTT 连接地址。
- 客户端 ID（Client ID）
  - 如果客户端使用一个重复的 Client ID 连接至服务器，将会把已使用该 Client ID 连接成功的客户端踢下线。
- 连接超时
- 保活周期
- 清除会话
  - 持久会话能被恢复的前提是客户端使用固定的 Client ID 再次连接，如果 Client ID 是动态的，那么连接成功后将会创建一个新的持久会话。
- 遗嘱消息
- 协议版本
  - 我们建议初次接触 MQTT 的开发者直接使用5.0版本。
# EMQX
## 代理订阅
- 目前 EMQX 企业版支持代理订阅。
- [代理订阅](https://docs.emqx.com/zh/enterprise/v4.0/advanced/proxy-subscriptions.html#%E5%86%85%E7%BD%AE%E4%BB%A3%E7%90%86%E8%AE%A2%E9%98%85)
## 数据存储
- Mnesia 数据库是 Erlang 内置的一个分布式 DBMS，可以直接存储 Erlang 的各种数据结构
- EMQX 使用 Mnesia 数据库存储自身运行数据，例如告警记录、规则引擎已创建的资源和规则、Dashbaord  
用户信息等数据，这些数据都将被存储在 mnesia 目录下，因此一旦删除该目录，将导致 EMQX 丢失所有业务数据。
## 分布式集群设计
- EMQ X 分布式的基本功能是将消息转发和投递给各节点上的订阅者
- 为实现此过程，EMQ X 维护了几个与之相关的数据结构：订阅表，路由表，主题树。
  - 订阅表：MQTT 客户端订阅主题时，EMQ X 会维护主题(Topic) -> 订阅者(Subscriber) 映射的订阅表。订阅表只存在于订阅者所在的 EMQ X 节点上
  - 路由表: 主题 - 节点。同一集群的所有节点，都会复制一份主题(Topic) -> 节点(Node) 映射的路由表
  - 主题树: 带统配符的主题匹配。EMQ X 集群中的每个节点也会维护一份主题树(Topic Trie) 的备份
- EMQ X 的订阅表在集群中是分片(partitioned)的，而主题树和路由表是共享(replicated)的。
## topic管理
- 订阅：指定主题过滤器 Topic，订阅的时候支持主题通配符 + 与 # 的使用
- 发布：指定目标主题，注意该主题不能包含通配符 + 或 #。指定消息 Retain 保留消息标志位
- 终端下发无需按设备创建topic，使用共享topic。消息体携带即可。减少topic数量带来的维护成本（订阅表，路由表，主题树）
- 尽量避免过多层级，降低主题树深度
- 主题层级：建议使用下划线代替斜杠，尽量减少不必要的层级。降低主题树深度
- 避免topic设计不合理导致topic增加
## 连接
- 限速：可通过配置限速控制每秒建联设备
## 性能影响
- 连接数：对于每一个 MQTT 长连接，EMQX 会创建两个 Erlang 进程，每个进程都会耗费一定的资源。连接数越高，所需的资源越多；
- 平均吞吐量：指的是每秒 Pub 和 Sub 的消息数量。吞吐量越高，EMQX 的路由处理和消息转发处理就需要更多的资源；
- 消息体大小：消息体越大，在 EMQX 中处理消息转发的时候在内存中进行数据存储和处理，所需的资源就越多；
- 主题数目：如果主题数越多，在 EMQX 中的路由表会相应增长，因此所需的资源就越多；
- QoS：消息的 QoS 越高，EMQX 服务器端所处理的逻辑会更多，因此会耗费更多的资源；
