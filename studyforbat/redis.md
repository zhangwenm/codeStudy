## Redis

#### 使用场景
- string 自增（incre）、分布式锁（setnx）、seesion共享、
- hash  购物车 过期功能不能用在field上，只能用在key上。集群规模不适合使用，会造成数据倾斜
- list 栈（lpush+lpop） 队列（lpush+rpop） 阻塞队列（lpush+brpop）
- set 抽奖用户、点赞、关注模型、电商商品筛选
- 有序集合 排行榜
#### 单线程的高性能
- 基于内存
- 执行命令单线程，持久化、快照等是多线程
- I/O多路复用
#### redis持久化
- 持久化：RDB
  - save同步，不消耗内存
  - bgsave异步（默认）,同时fork子线程利用写时复制技术将bgsave期间客户端的请求数据同时也写进rdb文件
  - 机器宕机会丢失数据
- 持久化AOF 
  - append 将修改命令写进AOF文件（先写入oscache，每隔一段时间fsync写磁盘）
  - fsync三种策略
    - 每次有命令追加AOF时就执行一次fsync，非常慢也非常安全
    - 每秒fsync，只会丢失一秒数据（默认）
    - 从不fsync，将操作交由操作系统处理。快，但不安全
- AOF重写（fork子线程）
  - 文件大小达到设置阈值
  - 自从上次重写后增长达到设置百分比时
- 同时开启
  - 恢复数据时优先使用AOF恢复，数据更全
- redis4.0 混合持久化
  - 默认关闭 
  - AOF重写时，不会单存将内存数据转换为命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且RDB快照  
  内容和增量AOF修改内存数据的命令存在一起，都写入AOF文件，新的文件一开始不叫appendonly.aof，重写完成后文件改名、  
  覆盖原有AOF文件，完成新旧文件的替换。于是机器重启的时候可以先加载RDB的内容，然后重放增量的AOF日志就可以完全取代  
  之前的AOF全量文件重放，重启效率提升
- 备份策略
  - 定时调度脚本，将AOF或者RDB文件备份到一个目录，保留最近48小时数据
  - 每天保留当天数据到一个目录，保留最近一个月
  - 每次复制备份的时候，把太旧的数据删除
  - 每天晚上将当前机器上的备份复制一份到其他机器或者云盘
#### 主从与哨兵
- 单节点内存配置一般小于10g,有局限

####数据结构
- string sds 只扩不减 
  - 二进制安全
  - 内存预分配,避免频繁的内存分配
    - len 现有字符串占用长度
    - free 空闲长度 当字符串变更长度不够用时，会将字节数组扩增到（len+所缺长度）*2
    - 当长度达到1M时，每次扩展1M
  - 兼容C语言函数库（自动添加\0） 
- 默认16个Db hash桶长度默认4 2倍扩容
- 先访问0，存在将整个hash桶搬到1，不存在访问1.


