## dubbo
- 刚开始设计的定位是RPC 框架，后期随着迭代，涉及到服务治理、服务监控、服务网关等，逐渐发展为服务管理框架
- ![](/studyforbat/pic/dubbo.png)
#### duboo的调用原理
- 服务提供者的导出
  - 服务导出的入口为ServiceBean的export()方法，在spring启动后通过ContextRefreshEvent()方法触发export的执行
  - ServiceBean对象代表一个dubbo服务，里边的参数表示服务的参数，timeout等，参数的值来自@service注解
  - 服务导出做两件事
    - 根据服务的参数启动对应的网络服务器，处理相应的网络请求
    - 将服务的信息注册到注册中心，同时还有向注册中心注册监听器，监听Dubbo的中的动态配置信息变更。
  - 导出步骤
    - 确定服务的参数
    - 确定服务支持的协议，Http协议就启动Tomcat、Jetty；Dubbo协议就启动Netty
    - 构造服务最终的URL
    - 将服务URL注册到注册中心去
    - 根据服务支持的不同协议，启动不同的Server，用来接收和处理请求
    - 因为Dubbo支持动态配置服务参数，所以服务导出时还需要绑定一个监听器Listener来监听服务的参数是否有修改，如果发现有修改，则需要重新进行导出
- 服务提供者的导入
  - spring启动的过程中，会给@Reference标注的属性进行赋值，赋值的对象为ReferenceBean对象调用get方法返回的对象，是一个代理对象
  - ReferenceBean表示应用想要引入的服务的信息，执行get的过程：
    - 检查更新参数，把ReferenceBean里的值更新为优先级最高的值
    - 生成代理对象
    - 生成代理对象前，会把消费者引入的服务设置的参数放入一个map，会根据map中的参数去注册中心寻找服务
    - 把消费者配置的所有配置中心取出来，调用Protocol的refer方法返回一个Invoker（表示服务执行者）对象
    - 将Invoker对象通过PROXY_FACTORY.getProxy(invoker);转为代理对象
    - 这个代理对象就会赋值给@Reference标注的属性
- 消费者调用
  - 最外层是Mock逻辑，调用前，调用后进行Mock,有mock的话先走mock
  - 从服务目录中，根据当前调用的方法和路由链，筛选出部分服务Invoker（DubboInvoker）
  - 对服务Invoker进行负载均衡，选出一个服务Invoker
  - 执行Filter链
  - AsyncToSyncInvoker完成异步转同步，因为DubboInvoker的执行是异步非阻塞的，所以如果是同步调用，则会在此处阻塞，直到拿到响应结果
  - DubboInvoker开始异步非阻塞的调用
  - HeaderExchangeChannel中会阻塞timeout的时间来等待结果，该timeout就是用户在消费端所配置的timeout
- Dubbo的异常处理
  - 服务提供者捕获异常，返回给消费端。有消费端抛出
#### SPI
- SPI ，全称为 Service Provider Interface(服务提供者接口)，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件  
夹查找文件，自动加载文件里所定义的类。
#### 负载均衡
- 如果在消费端和服务端都配置了负载均衡策略，以消费端为准。
- 活跃数计算
  - 逻辑是这样的：
    - 消费者会缓存所调用服务的所有提供者，比如记为p1、p2、p3三个服务提供者，每个提供者内都有一个属性记为active，默认位0 
    - 消费者在调用次服务时，如果负载均衡策略是leastactive 
    - 消费者端会判断缓存的所有服务提供者的active，选择最小的，如果都相同，则随机 
    - 选出某一个服务提供者后，假设位p2，Dubbo就会对p2.active+1 
    - 然后真正发出请求调用该服务 
    - 消费端收到响应结果后，对p2.active-1 
    - 这样就完成了对某个服务提供者当前活跃调用数进行了统计，并且并不影响服务调用的性能
- 加权轮询
  - 轮询，按公约后的权重设置轮询比率  借鉴于 Nginx 的平滑加权轮询算法，默认权重相同
- 加权随机 LoadBalance 默认
  - 随机，按权重设置随机概率。
  - 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。
- 最少活跃优先 + 加权随机  背后是能者多劳的思想
  - 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
  - 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
- 最短响应优先 + 加权随机 更加关注响应速度
- ConsistentHash LoadBalance 
  - 一致性 Hash，相同参数的请求总是发到同一提供者。
  - 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
#### 服务超时
- 在服务提供者和服务消费者上都可以配置服务超时时间，这两者是不一样的。
- 消费者调用一个服务，分为三步：
  - 消费者发送请求（网络传输）
  - 服务端执行服务
  - 服务端返回响应（网络传输）
- 如果在服务端和消费端只在其中一方配置了timeout，那么没有歧义，表示消费端调用服务的超时时间，消费端如  
果超过时间还没有收到响应结果，则消费端会抛超时异常，但，服务端不会抛异常，服务端在执行服务后，会检查执行  
该服务的时间，如果超过timeout，则会打印一个超时日志。服务会正常的执行完。
#### 集群容错
- 服务消费者在调用某个服务时，这个服务有多个服务提供者，在经过负载均衡后选出其中一个服务提供者之后进行调用，  
但调用报错后，Dubbo所采取的后续处理策略。
- Failover Cluster 默认
  - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 
  - ="2" 来设置重试次数(不含第一次)。
- Failfast Cluster 
  - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
- Failsafe Cluster 
  - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作
- Failback Cluster 
  - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
- Forking Cluster 
  - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。
- Broadcast Cluster 
  - 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。
  - 现在广播调用中，可以通过 broadcast.fail.percent 配置节点调用失败的比例，当达到这个比例后，BroadcastClusterInvoker 将不再  
  调用其他节点，直接抛出异常。 broadcast.fail.percent 取值在 0～100 范围内。默认情况下当全部调用失败后，才会抛出异常。 broadcast.fail.percent  
  只是控制的当失败后是否继续调用其他节点，并不改变结果(任意一台报错则报错)。broadcast.fail.percent 参数 在 dubbo2.7.10 及以上版本生效。
#### 服务降级 可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。
- 服务降级表示：服务消费者在调用某个服务提供者时，如果该服务提供者报错了，所采取的措施。
- 策略
  - 消费方对该服务的方法调用都直接返回 null 值，不发起远程调用
  - 消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。
- 集群容错和服务降级的区别在于：
  - 集群容错是整个集群范围内的容错
  - 服务降级是单个服务提供者的自身容错
#### 本地存根
- 本地存根，名字很抽象，但实际上不难理解，本地存根就是一段逻辑，这段逻辑是在服务消费端执行的，这段逻辑一般都是由服务提供者提供，  
服务提供者可以利用这种机制在服务消费者远程调用服务提供者之前或之后再做一些其他事情，比如结果缓存，请求参数验证等等。
#### 延迟暴露
- 果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。我们在 Dubbo 2.6.5 版本中对服务延  
迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay > 0）服务的倒计时动作推迟到了 Spring 初始化完成后进行。你在使用 Dubbo 的过程中，  
并不会感知到此变化，因此请放心使
- Dubbo 2.6.5 之前版本
  - <dubbo:service delay="-1" /> 延迟到 Spring 初始化完成后，再暴露服务
  - 延迟 5 秒暴露服务 <dubbo:service delay="5000" />
- Dubbo 2.6.5 及以后版本 
  - 所有服务都将在 Spring 初始化完成后进行暴露，如果你不需要延迟暴露服务，无需配置 delay。
  -延迟 5 秒暴露服务 <dubbo:service delay="5000" />
#### 本地伪装
- 本地伪装就是Mock，Dubbo中Mock的功能相对于本地存根更简单一点，Mock其实就是Dubbo中的服务容错的解决方案。
#### 参数回调
- 首先，如果当前服务支持参数回调，意思就是：对于某个服务接口中的某个方法，如果想支持消费者在调用这个方法时能  
设置回调逻辑，那么该方法就需要提供一个入参用来表示回调逻辑。
- 因为Dubbo协议是基于长连接的，所以消费端在两次调用同一个方法时想指定不同的回调逻辑，那么就需要在调用时在指定一定key进行区分。
- ![](/studyforbat/pic/dubbocallback.png)
#### 异步调用
- 主要要理解CompletableFuture，如果不理解，就直接把它理解为Future
#### 泛化调用
- 在Dubbo中，如果某个服务想要支持泛化调用，就可以将该服务的generic属  
性设置为true，那对于服务消费者来说，就可以不用依赖该服务的接口，直接利用GenericService接口来进行服务调用。
#### 泛化服务
- 实现了GenericService接口的就是泛化服务
#### 异步调用
- 需要服务提供者事先定义 CompletableFuture 签名的服务，调用时返回一个CompletableFuture，通过whenComplete
#### 优雅停机
- 服务提供方
  - 停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。
  - 然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。
- 消费方
  - 停止时，不再发起新的调用请求，所有新的调用在客户端即报错。
  - 然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。
  - 设置优雅停机超时时间，超时强制关闭。dubbo.service.shutdown.wait=15000
  - 也可以通过DubboShutdownHook.destroyAll();
#### RPC 通信协议
- Triple 协议 
- gRPC
- Thrift
- JsonRPC
- Hessian2
- REST




