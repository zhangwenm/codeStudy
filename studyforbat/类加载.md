## 类加载
- 流程图
![](/studyforbat/pic/类加载.png)
![](/studyforbat/pic/类加载1.png)
- 步骤
  - 加载：加载硬盘上的字节码文件到内存，生成class对象
  - 验证：校验字节码文件的正确性
  - 准备：各类的静态变量分配内存赋初默认值
  - 解析：将符号引用转换为直接引用，该阶段会把一些静态方法（符号引用，比如main方法）替换为指向数据所存内存的地址或指针，这就是馊味的静态链接。  
  动态链接是指在运行期间完成符号引用替换为直接引用
  - 初始化：各类的静态变量赋指定值，执行静态代码块
  - 使用
  - 卸载
- 类被加载到方法区后主要包含：运行时常量池、类型信息、字段信息、方法信息、类加载器引用、对应class实例等
  - 类加载器：加载类
  - 类实例：作为方法区中访问类定义的入口
#### 类加载器由上至下  类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份
- 引导类加载器（Launche，c++实现，开发不可见）：加载jre的lib目录下的核心类库 rt.jar、charset.jar
- 扩展类加载器（ExtClassLoader）:加载jre的lib目录下的ext扩展目录中的jar
- 应用类加载器（AppClassLoade）：负责加载alsspath下的类包
- 自定义类加载器（自定义类加载器的父加载器都为应用类加载）：加载用户自定义路径下的jar
#### 双亲委派
![](/studyforbat/pic/双亲委派.png)
- 流程
  - 先检查下类是否已经加载，如果已加载直接返回
  - 未加载看是否有父加载器，有的话调用父加载器进行加载或者bootstrrap类加载器进行加载
  - 如果父类加载和bootatrap类加载器都加载不到当前类，则由当前类加载器进行加载
- 双亲委派目的
  - 沙箱安全机制：防止核心类库被篡改
  - 避免类的重复加载，保证加载类的唯一性
- 自定义类加载器继承 java.lang.ClassLoader 类，重写findclass（）
#### 打破双亲委派
- tomcat
  - 保证每个应用程序类库隔离
  - 相同类库相同版本共享
  - web容器类库与应用程序类库隔离
  - jsp修改不重启
    ![](/studyforbat/pic/tomcat类加载器.png)
- 同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一
  样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类
  加载器也是同一个才能认为他们是同一个