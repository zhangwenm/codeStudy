## Elasticsearch

#### 分布式搜索引擎，基于lucene框架 
- lucene
  - 只能在java中使用
  - 代码繁杂
  - 不支持集群
  - 索引和应用在同一机器
  - ES 配合三方分词器（最粗粒度，最细粒度）
    - INDEX(database数据库)，相似文档的集合
    - mapping（文档结构）
    - type（表）
    - Documnet（行）
    - field字段
- 倒排索引
  - 存储的的时候进行关键词切分，建立关键词与文档的对应关系表，称之为倒排索引（反向索引）
  - 分词（位置，出现次数）
  - 排序
- DSL查询
  - query DSL
  - filter DSL
- query DSL 结果不会放进缓存
  - term 不会进行分词
  - match 模糊匹配 会对关键字分词
- 文档映射
  - 动态映射：不需要mapping，自动根据字段识别类型
  - 静态映射：先定义好字段类型、分词器等
  - index：属性用来配置是否开启分词建立对应关系
  - store：是否存储文档数据
  - String 包含text keyword
    - text会进行分词，不能排序和聚合
    - keyword不会进分词
  - 修改静态映射：命令行将原索引数据导入新索引，重命名新索引

#### 架构
- master，集群中只有一个master
  - 管理索引、分配分片
  - 维护元数据
  - 管理集群节点状态
  - 不负责写入和查询
- DataNode
  - 数据写入、检索，内存要大一些
  - 分片、副本。高版本默认一个
- 一个索引可以分为多个分片，每个分片又可以设置多个副本
  - 分片
    - 每个分片都有主分片
    - 主分片和从分片不在同一节点
    - 分片允许水平分割/扩展内容容量
    - 允许在分片上做分布式、并行的操作，提高吞吐率、
    - 不能改变分片数量
  - 副本
    - 容灾
    - 扩展搜索/吞吐量，搜索可以再所有的副本上并行进行
    - 可以动态的改变副本数量
- 乐观并发控制
  - 高版本用的seqno控制，低版本用version控制
- 写入路程
  - 选择任意一个DataNode发送请求，该节点成为协调节点
  - 计算得到要写入的分片 shard = hash(routing) % number_of_primary_shards
    routing 是一个可变值，默认是文档的 _id
  - 协调节点将请求路由到主分片所在的节点，处理写请求写入索引库并同步到其他副本
  - 主分片和从分片都处理好文档，返回client
    ![](/studyforbat/pic/es_write.png)
- 检索原理
  - client发起请求，某个DataNode收到请求成为协调节点
  - 协调节点将请求广播到数据节点，这些数据节点的分片会处理查询请求
  - 每个分片进行数据查询，将查询到符合条件的数据放入一个优先队列，并将这些数据的文档ID、节点信息、分片信息  
  返回个协调节点
  - 协调节点将结果汇总、全局排序
  - 协调节点向包含这些文档ID的分片发送请求，收到数据后返回给客户端
    ![](/studyforbat/pic/es_read.png)
- es准时数据库
  - 当数据写入到es分片时，会先写入到内存中，然后通过内存的buffer生成一个segment并刷到文件系统缓存中  
  之后文件才能被检索，默认每秒刷一次
  - 写入内存的同时，也会记录translog日志，在refresh期间出现异常会根据translog文件进行恢复
  - 等到segment数据都刷到磁盘清空translog日志
  - 默认30分钟将文件系统缓存刷盘
  - segment太多时会进行合并生成大的segment，减少索引查询的I/O开销，真正删除之前执行过delete操作的数据
- 不同节点介紹
  - 当节点node.master：false node.data: false时，该节点只能作为路由节点，用来协调主节点和数据节点，路由请求
  - 数据节点主要是存储索引数据的节点，并对文档进行操作，对cpu、内存、IO等要求较高
- 生产设置建议
  - 设置三台或以上的主节点，维护整个集群的状态。再根据数据量设置一批数据节点，负责存储数据。如果用户请求比较频繁的话  
  ，数据节点压力比较大，可以适当设置一些client节点，负责负载均衡请求转发等