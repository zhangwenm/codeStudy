## 线程
- 线程五种状态
  - 新建
  - 运行
  - 阻塞
  - 等待
  - 超时等待
  - 终结
- 线程池五种状态
  - running ：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行 处理
  - SHUTDOWN ：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务
  - STOP：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务
  - TIDYING明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。  
  当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；  
  可以通过重载terminated()函数来实现。
  - TERMINATED：线程池彻底终止，就变成TERMINATED状态。
- 核心参数
  - corePoolSize;线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当 前线程数等于corePoolSize；如果当前线程数为corePoolSize，  
  继续提交的任务被保存到 阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会 提前创建并启动所有核心线程。
  - maximumPoolSize:线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线 程执行任务，前提是当前线程数小于maximumPoolSize；
  - keepAliveTime线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时 候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，  
  而是会等待，直到等待 的时间超过了keepAliveTime；
  - unit keepAliveTime的单位；
  - workQueue用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供 了如下阻塞队列：
  - threadFactory它是ThreadFactory类型的变量，用来创建新线程。默认使用 Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程  
  时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设 置了线程的名称。
  - handler线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必 须采取一种策略处理该任务，线程池提供了4种策略：
    - AbortPolicy：直接抛出异常，默认策略
    - CallerRunsPolicy：用调用者所在的线程来执行任务；
    - DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
    - DiscardPolicy：直接丢弃任务；
      ![](/studyforbat/pic/线程池.png)