## JVM

#### JVM整体结构&内存模型
![](/studyforbat/pic/jvm_memory.png)
- 模块
  - java虚拟机栈：线程私有，里边存放的栈桢帧，栈帧组成
    - 局部变量表：存放局部变量（静态变量存放在元空间（方法区））
    - 操作数栈：存放操作数（局部变量对应的值，如果对象存放在对堆空间）
    - 动态链接：直接引用
    - 方法出口：方法调用的位置
  - 本地方法栈：给本地方法是用
  - 堆：存放对象。
    - 三分之一年轻代 miinor gc
      - eden 8/10  
      - 2/10 survivor
        - 1/10 s0  1/10 s1
    - 三分之二老年代 full gc
  - 元空间（方法区）：常量、静态变量、类信，1.8之后分配在本地内存
  - 程序计数器：字节码指令地址
  - 常量池中主要存放两大类常量：字面量和符号引用。
    - 字面量：字面量就是指由字母、数字等构成的字符串或者数值常量
      - 字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=1 这里的a为左值，1为右值。在这个例子中1就是字面
        量。
      - ```1 int a = 1;
        2 int b = 2;
        3 int c = "abcdefg";
        4 int d = "abcdefg";
        ```
      - 符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量：
        - 类和接口的全限定名
        - 字段的名称和描述符
        - 方法的名称和描述符
        - 上面的a，b就是字段名称，就是一种符号引用
        - 这些常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装
          入内存就变成运行时常量池，对应的符号引用在程序加载或运行时会转变代码在内存区域的的直接引用，也
          就是我们说的动态链接了。例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的
          地址，主要通过对象头里的类型指针去转换直接引用。
  - 字符串常量池 JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化
    - 为字符串开辟一个字符串常量池，类似于缓存区
    - 创建字符串常量时，首先查询字符串常量池是否存在该字符串
    - 存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中
  - 1.7及以上
    - ``String s = "zhuge"; // s指向常量池中的引用``
    - 这种方式创建的字符串对象，只会在常量池中。
    - 因为有"zhuge"这个字面量，创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象
      如果有，则直接返回该对象在常量池中的引用；
    - 如果没有，则会在常量池中创建一个新对象，再返回引用。
    - ``String s1 = new String("zhuge"); // s1指向内存中的对象引用``
    - 这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用。
    - 因为有"zhuge"这个字面量，所以会先检查字符串常量池中是否存在字符串"zhuge"
    - 不存在，先在字符串常量池里创建一个字符串对象；再去内存中创建一个字符串对象"zhuge"；
    - 存在的话，就直接去堆内存中创建一个字符串对象"zhuge"；
    - 最后，将堆内存中的引用返回。
    - ``String s1 = new String("zhuge");
      String s2 = s1.intern();
      System.out.println(s1 == s2); //false ``
    - String中的intern方法是一个 native 的方法，当调用 intern方法时，如果池已经包含一个等于此String对象的字符串
      （用equals(oject)方法确定），则返回池中的字符串。否则，将intern返回的引用指向堆中的字符串，即 s1和s2都指向堆中(jdk1.6版本需要将
      s1 复制到字符串常量池里，s1指向堆中，s2指向常量池中)。
  - 1.7String
    - ![](/studyforbat/pic/1.7string.png)
  - 1.8String
    - ![](/studyforbat/pic/1.8string.png)
    - ``String s0="zhuge";
      2 String s1="zhuge";
      3 String s2="zhu" + "ge";
      4 System.out.println( s0==s1 ); //true
      5 System.out.println( s0==s2 ); //true``
      - ”zhu”和”ge”也都是字符串常量，当一个字 符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所
        以s2也同样在编译期就被优化为一个字符串常量"zhuge"
    - ``1 String s0="zhuge";
      2 String s1=new String("zhuge");
      3 String s2="zhu" + new String("ge");
      4 System.out.println( s0==s1 ); // false
      5 System.out.println( s0==s2 )； // false
      6 System.out.println( s1==s2 ); // false``
      - s2因为有后半部分 new String(”ge”)所以也无法在编译期确定，所以也是在堆中新创建对象”zhuge”的引用
    - ``1 String a = "ab";
      2 String bb = "b";
      3 String b = "a" + bb;
      4
      5 System.out.println(a == b); // false``
      - JVM对于字符串引用，由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，
        即"a" + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为
        false。
    - ``1 String a = "ab";
      2 final String bb = "b";
      3 String b = "a" + bb;
      4
      5 System.out.println(a == b); // true``
      - 分析：和示例4中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷
        贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的"a" + bb和"a" + "b"效果是一样的。故上面程序的结果
        为true。
    - ``1 String a = "ab";
      2 final String bb = getBB();
      3 String b = "a" + bb;
      4
      5 System.out.println(a == b); // false
      6
      7 private static String getBB()
      8 {
      9 return "b";
      10 }``
      - 分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和"a"来动态
        连接并分配地址为b，故上面 程序的结果为false。
    - ``1 //字符串常量池："计算机"和"技术" 堆内存：str1引用的对象"计算机技术"
      2 //堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会new String()，这个String才是真正返回的对
      象引用
      3 String str2 = new StringBuilder("计算机").append("技术").toString(); //没有出现"计算机技术"字面量，所以不会在常量池里生
      成"计算机技术"对象
      4 System.out.println(str2 == str2.intern()); //true
      5 //"计算机技术" 在池中没有，但是在heap中存在，则intern时，会直接返回该heap中的引用
      6
      7 //字符串常量池："ja"和"va" 堆内存：str1引用的对象"java"
      8 //堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会new String()，这个String才是真正返回的对
      象引用
      9 String str1 = new StringBuilder("ja").append("va").toString(); //没有出现"java"字面量，所以不会在常量池里生成"java"对象
      10 System.out.println(str1 == str1.intern()); //false
      11 //java是关键字，在JVM初始化的相关类里肯定早就放进字符串常量池了
      12
      13 String s1=new String("test");
      14 System.out.println(s1==s1.intern()); //false
      15 //"test"作为字面量，放入了池中，而new时s1指向的是heap中新生成的string对象，s1.intern()指向的是"test"字面量之前在池中生成的
      字符串对象``
  - java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫对象池，在堆上)，这些类是
    Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外
    Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负
    责创建和管理大于127的这些类的对象。因为一般这种比较小的数用到的概率相对较大。
    - ``1 public class Test {
      3 public static void main(String[] args) {
      4 //5种整形的包装类Byte,Short,Integer,Long,Character的对象，
      5 //在值小于127时可以使用对象池
      6 Integer i1 = 127; //这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池
      7 Integer i2 = 127;
      8 System.out.println(i1 == i2);//输出true
      9
      10 //值大于127时，不会从对象池中取对象
      11 Integer i3 = 128;
      12 Integer i4 = 128;
      13 System.out.println(i3 == i4);//输出false
      14
      15 //用new关键词新生成对象不会使用对象池
      16 Integer i5 = new Integer(127);
      17 Integer i6 = new Integer(127);
      18 System.out.println(i5 == i6);//输出false
      19
      20 //Boolean类也实现了对象池技术
      21 Boolean bool1 = true;
      22 Boolean bool2 = true;
      23 System.out.println(bool1 == bool2);//输出true
      24
      25 //浮点类型的包装类没有实现对象池技术
      26 Double d1 = 1.0;
      27 Double d2 = 1.0;
      28 System.out.println(d1 == d2);//输出false
      29 }
      30 }``
- JVM参数设置
  ![](/studyforbat/pic/jvm_param.png)
- -XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。
- -XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发
  full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超
  过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。
- 由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生
  了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，
  对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。
#### 对象创建
- 流程
  ![](/studyforbat/pic/object_process.png)
  - 类加载检查，是否能定位到常量池中的一个类的符号引用，类是否已加载
  - 分配内存，类加载的时候内存大小已确定，分配内存就是在堆上开辟一块空间
    - 指针碰撞：内存规整，指针作为分界点，通过移动至真分配内存
    - 空闲列表：内存不规整，维护可用内存的列表
    - 并发控制
      - CAS失败重试保证更新操作的原子性
      - 本地线程分配缓冲
  - 初始化：将分配到的内存空间初始化为0，不包括对象头，如果使用TLAB，则提前至分配TLAB时进行。保证了对象不赋初值就可以使用
  - 设置对象头
    - 对象内存中的布局
      - 对象头
        - 对于自身的运行时数据哈希、gc分代年龄、锁状态等
        - 类型指针，即指向它元数据的指针，用以确定属于哪个类的实例
          ![](/studyforbat/pic/object_header.png)
  - 执行 init方法
- 指针压缩（有默认的开启机制）
  - 首先是内存问题，由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要消耗更多的内存，通常要比32位
    系统额外增加10%～30%的内存消耗；其次是多个机构的测试结果显示，64位虚拟机的运行速度在各
    个测试项上几乎都全面落后于32位虚拟机，两者大约有15%的性能差距。
  - 但由于上述的原因，许多企业应用都仍然选择使用虚拟集群等方式继续在32位虚拟机中进行部
    署。Sun也注意到了这些问题，并做出了一些改善，在JDK 1.6 Update 14之后，提供了普通对象指针压
    缩功能（不建议设置，由虚拟机开启机制开启）
  - 在执行代码时，动态植入压缩指令以节省内存消耗。但是开启压缩指针
    会增加执行代码数量，因为所有在Java堆里的、指向Java堆内对象的指针都会被压缩，这些指针的访问
    就需要更多的代码才可以实现，而且并不仅只是读写字段才受影响，在实例方法调用、子类型检查等
    操作中也受影响，因为对象实例指向对象类型的引用也被压缩了
- 分配流程
![](/studyforbat/pic/memory_process.png)
  - 优先在栈上分配
    - 逃逸分析：
      - 分析对象动态作用域，对象在方法中被创建后可能被外部方法访问，会逃逸
      - 不会被别的方法访问，我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内
        存一起被回收掉
    - 标量替换：不会被外部访问，对象可以拆解，jvm不会创建该对象，而是将该  
    - 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员  
    变量在栈帧或寄存器上分配空间，这样就 不会因为没有一大块连续空间导致对象内存不够分
    - 标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量，标量的对立就是可以被进一步分解的量，而这种量称之为聚合量
  - eden区分配
    - eden区空间不够，yang gc。大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活
      的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回
      收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所
      以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即
  - 大对象直接进入老年代：大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。避免为大对象分配内存时的复制操作而降低效率。
  - 长期存活的对象将进入老年代。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor
    空间中，并将对象年龄设为1。当它的年龄增加到一定程度 （默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中
  - 对象动态年龄判断：，如果在Survivor空间中相同年龄所有对象大小的总和大于
    Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代， 对象动态年
    龄判断机制一般是在minor gc之后触发的。
  - 老年代空间分配担保机制：年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间
    如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)
    就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了
    如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。
    如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，
    如果回收完还是没有足够空间存放新的对象就会发生"OOM"
    当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full
    gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”
    ![](/studyforbat/pic/分配担保.png)
- 对象内存回收
  - 引用计数法：无法解决循环引用
  - 可达性分析算法 GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等
    ![](/studyforbat/pic/gc_root.png)
    - finalize()方法最终判定对象是否存活
    - 不可达也并不一定会被回收
      - 一次筛选： 筛选的条件是此对象是否有必要执行finalize()方法，假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用
        过，那么虚拟机将这两种情况都视为“没有必要执行，对象将直接被回收。
      - 二次标记：如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的
        队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()
        方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。
        这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导
        致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对
        象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对
        象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己
        （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集
        合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个
        对象的finalize()被执行，但是它仍然可以存活。
- 无用类 
  - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
  - 加载该类的 ClassLoader 已经被回收。
  - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
#### 垃圾收集器
##### 回收算法
![](/studyforbat/pic/huishousuanfa.png)
- 分代收集
  - 新生代99%都会被回收，采用复制算法
  - 老年代存活几率较高，标记清除或者标记整理
  - 标记复制：内存分为两块，一块使用，一块保留。用完以后将存活对象复制到另一块。空间浪费
  - 标记清除：标记存活的对象，统一清除未标记的对象。效率低，形成空间碎片
  - 标记整理：先标记存活对象，将存活对象移向一端，清除端边界以外的内存
###### 收集器
![](/studyforbat/pic/收集器.png) 
- serial
  - 单线程
  - 新生代复制 老年代标记整理
  - 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率
  - Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5
    以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。
- Parallel Scavenge收集器  Parallel Scavenge收集器及后面提到的G1收集器等都没有使用HotSpot中原本设计的垃圾收集器的分代框架，  
而选择另外独立实 现。
  - serial的多线程版本
  - Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停
    顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。
  - 新生代采用复制算法，老年代采用标记-整理算法。
- Parallel Old
  - Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及
    CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集
    器)。
- ParNew收集器
  - ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。
    新生代采用复制算法，老年代采用标记-整理算法。
  - 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收
    集器，后面会介绍到）配合工作。
- CMS收集器
  - CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体
    验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程
    （基本上）同时工作。
  - CMS收集器是一种 “标记-清除”算法实现的
    - 初始标记： 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。
    - 并发标记： 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但
      是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变
    - 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对
      象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三
      色标记里的增量更新算法(见下面详解)做重新标记。
    - 并发清理： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑
      色不做任何处理(见下面三色标记算法详解)。
    - 并发重置：重置本次GC过程中的标记数据。
  - 因此CMS收集器不能像其他收集器那样等待 到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK
    5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果
    在实际应用中老年代增长并不是太快，可以适当调高参数-XX：CMSInitiatingOccu-pancyFraction的值
    来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动
    阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满
    足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不
    得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，
    但这样停顿时间就很长了。所以参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致
    大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。
  - 并发收集、低停顿
    - 对CPU资源敏感（会和服务抢资源）；
    - 无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；
    - 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-
      XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理
    - 执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并
      发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是"concurrent
      mode failure"，此时会进入stop the world，用serial old垃圾收集器来回收
  - 三色标记 
  - ![](/studyforbat/pic/sanse1.png)
    - 黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描
      过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过
      灰色对象） 指向某个白色对象。初始状态只有gc root是黑色的，引用是有向的，只有被黑色对象引用的对象才能存活
    - 灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
    - 白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若
      在分析结束的阶段， 仍然是白色的对象， 即代表不可达。
      ![](/studyforbat/pic/sanse.png) 
  - CMS是基于增量更新
    来做并发标记的，G1、Shenandoah则是用原始快照来实现。
  - 多标-浮动垃圾
    - 在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过
      (被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动
      垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。
      另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分
      对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分
  - 漏标-读写屏障 
    - 写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切
      面[2]，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的
      前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值
      后的则叫作写后屏障（Post-Write Barrier）。HotSpot虚拟机的许多收集器中都有使用到写屏障，但直
      至G1收集器出现之前，其他收集器都只用到了写后屏障
    - 漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： 增量更新（Incremental
      Update） 和原始快照（Snapshot At The Beginning，SATB） 。
      增量更新就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之
      后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向
      白色对象的引用之后， 它就变回灰色对象了。
      原始快照就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后，
      再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑
      色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)
      以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。
      - 所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）
      - SATB与增量更新都依赖于写屏障
      - 其并发标记时对漏标的处理方案如下：
        - CMS：写屏障 + 增量更新
        - G1，Shenandoah：写屏障 + SATB
        - ZGC：读屏障
      - 为什么G1用SATB？CMS用增量更新？
        - 我的理解：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描
          被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代
          区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC
          再深度扫描。
      - 记忆集与卡表
        - 在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。
          为此，在新生代可以引入记录集（Remember Set）的数据结构（记录从非收集区到收集区的指针集合），避免把整个
          老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集
          （Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。
          垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引
          用指针的全部细节。
        - hotspot使用一种叫做“卡表”(cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系，
          可以类比为Java语言中HashMap与Map的关系。
        - 卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡
          页”。
        - hotSpot使用的卡页是2^9大小，即512字节
          ![](/studyforbat/pic/card.png) 
        - 一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变
          脏，否则为0.
          GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。
          卡表的维护
          卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。
          Hotspot使用写屏障维护卡表状态。
        - 卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。伪共享是处
          理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）
          为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影
          响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。
          假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓
          存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对
          象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免
          伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元
          素未被标记过时才将其标记为变脏。
        - 开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损
          耗，是否打开要根据应用实际运行情况来进行测试权衡
- G1收集器(-XX:+UseG1GC) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC
  停顿时间要求的同时,还具备高吞吐量性能特征.
  - G1将java堆划分为许多大小相等块（region），jvm最多可以有2048个块
  - 一般块大小等于堆除以2048，也可以指定块大小，一般用默认
  - G1保留了年轻代、老年代的概念，他们都是region（可以不连续）的集合
  - 默认年轻代堆内占比为5%，可以设置这个初始占比，jvm会不停给年轻代增加占比，但不会超过60%。eden:survior=8:1:1
  - 一个region可能之前年轻代，回收后可能分给老年代，region区域会动态变化
  - G1有专门的大对象的区域（humongous），而不是直接进入老年代。当对象大小超过过一个region的50%时进入humongous，对象  
  太大可能会横跨多个region。full gc时也会回收humongous
  - G1收集流程
    - 初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；
    - 并发标记（Concurrent Marking）：同CMS的并发标记
    - 最终标记（Remark，STW）：同CMS的重新标记
    - 筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期
      望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划
      - 如果回收太多region会超出预期时间，那么可以减少回收的region，年轻代和老年代主要使用的是复制算法，几乎不会有太多内存碎片
        ![](/studyforbat/pic/G1.png)
    - G1会维护一个回收优先级列表，每次优先选择回收价值大的区域进行回收
    - 特点
      - 并行与并发：G1收集器仍然可以通过并发的方式 让java程序继续执行。
      - 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
      - 空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部
        上来看是基于“复制”算法实现的。
      - 这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了
        追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数"-
        XX:MaxGCPauseMillis"指定)内完成垃圾收集。
        - 停顿时间过短：收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。最终占满堆导致full gc（1-3百毫秒比较合适）
    - YoungGC：YoungGC年轻代用完并不会立即回收，而是判断回收时间是否远小于-XX:MaxGCPauseMills设定的值，如果是的话，增加eden区的region  
    存放对象。下次放满，回收时间接近-XX:MaxGCPauseMills就会进行回收Young GC 
    - MixedGC：老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有young和部分old(根据期望的  
    GC停顿时间确定old区垃圾收集的优先顺序)以及大对象。正常先做Mix Gc，将存活的对象复制到另一部分region，如果不够用进行full gc
    - Full gc：停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这
      个过程是非常耗时的。(Shenandoah优化成多线程收集了)
  - 什么场景适合使用G1
    - 50%以上的堆被存活对象占用
    - 对象分配和晋升的速度变化非常大
    - 垃圾回收时间特别长，超过1秒
    - 8GB以上的堆内存(建议值)
    - 停顿时间是500ms以内
- ZGC收集器（jdk11，实验性质）
  - 目标
    - 支持TB量级的堆
    - 最大GC停顿时间不超10ms
    - 奠定未来GC特性的基础。
    - 最糟糕的情况下吞吐量会降低15%
  - 特点
    - 不分代
    - 分为不同大小的region，有的固定有的不固定
    - 依赖读屏障和颜色指针来实现并发标记-整理
    - 颜色指针
      - ZGC的GC信息保存在指针中。
  - 收集流程
    - 并发标记（Concurrent Mark）：与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记
      (Mark Start)和最终标记(Mark End)也会出现短暂的停顿，与G1不同的是， ZGC的标记是在指针上而不是在对象
      上进行的， 标记阶段会更新染色指针中的Marked 0、 Marked 1标志位。
    - 并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收
      集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的
      Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。
    - 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存
      活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象
      到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并
      发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发
      表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指
      针的“自愈”（Self-Healing）能力。
    - 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但
      是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的
      工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节
      省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。
  - 浮动垃圾
    - 解决方案：
      - 目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间
      - 还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频
        繁、更快的收集。
  - ZGC触发时机
    - 定时触发，默认为不使用，可通过ZCollectionInterval参数配置。
    - 预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。
    - 分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，
      在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。
    - 主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上
      次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。
- 如何选择垃圾收集器
  - 优先调整堆的大小让服务器自己来选择
  - 如果内存小于100M，使用串行收集器
  - 如果是单核，并且没有停顿时间的要求，串行或JVM自己选择
  - 如果允许停顿时间超过1秒，选择并行或者JVM自己选
  - 如果响应时间最重要，并且不能超过1秒，使用并发收集器
  - 4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC
    ![](/studyforbat/pic/shoujiqi.png)
- 安全点：是否具有让程序长时间执行的特征，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转
  等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。。
  这些特定的安全点位置主要有以下几种:
  - 方法返回之前
  - 调用某个方法之后 
  - 抛出异常的位置 
  - 循环的末尾
  - 大体实现思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程
    时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和
    安全点是重合的。
- 安全区域：Safe Point 是对正在执行的线程设定的。 
    - 如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。因此 JVM 引入了 Safe Region。
    - Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。
#### 调优
- jmap ‐dump:format=b,file=eureka.hprof 14660 dump文件 
- 用jstack加进程id查找死锁，
- jstack找出占用cpu最高的线程堆栈信息
  - 1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如19663
  - 2，按H，获取每个线程的内存情况
  - 3，找到内存和cpu占用最高的线程tid，比如19664
  - 转为十六进制得到 0x4cd0，此为线程id的十六进制表示
  - 执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调
    用方法
- JVM运行情况预估
  - 用 jstat -gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的
    JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。
    - jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对
      象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不
      同的时间分别估算不同情况下对象增长速率。
    - Young GC的触发频率和每次耗时
      知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC
      公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。
    - 每次Young GC后有多少对象存活和进入老年代
      这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，
      survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次
      Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。
    - Full GC的触发频率和每次耗时
      知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。
    - 优化思路其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年
      代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。
- 系统频繁Full GC导致系统卡顿是怎么回事
  - 经过分析感觉可能会由于对象动态年龄判断机制导致full gc较为频繁
  - jstat ‐gc 13456 2000 10000
    ![](/studyforbat/pic/gcstat.png)
  - **对于对象动态年龄判断机制导致的full gc较为频繁可以先试着优化下JVM参数，把年轻代适当调大点**
- 我们可以推测下full gc比minor gc还多的原因有哪些？
  - 1、元空间不够导致的多余full gc
  - 显示调用System.gc()造成多余的full gc，这种一般线上尽量通过XX:+
    DisableExplicitGC参数禁用，如果加上了这个JVM启动参数，那
    么代码中调用System.gc()没有任何效果
  - 3、老年代空间分配担保机制
- 最快速度分析完这些我们推测的原因以及优化后，我们发现young gc和full gc依然很频繁了，而且看到有大量的对象频繁的被挪动到老年
  代，这种情况我们可以借助jmap命令大概看下是什么对象
  ![](/studyforbat/pic/jmap.png)