## 面试总结

#### 国美 
- java子线程中获取父线程的threadLocal中的值
  - InheritableThreadLocal,实现子线程获取父线程的变量信息，  
    如果允许new的线程继承当前线程的threadlocalMap，那么new的  
    线程会copy一份当前线程也就是父线程的inheritableThreadLocals 。  
    这儿也可以说明继承有两条件，new的线程允许继承(默认允许)，父线程的inheritableThreadLocals 不为null。
- 生产上线程池拒绝策略执行之后，抛出异常，如何处理的
  - submit 方法提交一个会抛出运行时异常的任务，捕不捕获异常都可以。
    - 无论如何都不会触发 dispatchUncaughtException 方法。因为 submit 方法提交，不论你捕获与否，源码里面都帮你捕获了
  - execute 方法提交一个会抛出运行时异常的任务，不捕获异常。
    - 如果不捕获异常，会触发 dispatchUncaughtException 方法，因为 runWorker 方法的源码里面虽然捕获了异常，但是又抛出去了
  - submit 或者 execute 提交，让线程池饱和之后抛出拒绝异常，代码没有捕获异常。
    - 和第二种其实是一样的。没有捕获，就会触发dispatchUncaughtException。
- 线程池的线程数根据什么设置的，比如是双核，如何设置
  - 如果是 CPU 密集型的，可以把核心线程数设置为核心数+1
    - 即使当计算（CPU）密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个“额外”的线程也能确保 CPU 的时钟周期不会被浪费。  
    备份线程
  - IO 密集型
    - 设置为 2*CPU 核心数
  - allowCoreThreadTimeOut设置为true允许回收核心线程，默认为false
  - prestartCoreThread启动所有的核心线程数
- 线程池如何去平衡插入和阻塞的、根据什么通知插入和阻塞
  - 
- 可重入锁是如何实现的
  - 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁  
  （前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞
  - 获取锁的时候会判断持有锁的线程是否为当前线程
  - 非重入是直接修改状态不去判断
- hashSet如何保证唯一
  - 底层实现为hashmap，key相同会覆盖
- HashMap解决哈希冲突一定会在链表上插入元素吗
  - 链表长度大于8且数组长度大于流64会转为红黑树
- 生产上初始堆的大小和最大堆的大小设置的值一样吗，为什么一样，或者为什么不一样
  - 一样。如果设置成不一样的话，虽然能动态申请内存，但是这种内存充分配会有系统开销
- volatile可见性失效的情况，举例说明
  - volatile修饰的变量会通过总线嗅探机制，保证变量被修改后，其他线程缓存行的变量副本失效  
  ，从新去主存读取。i++操作，非原子
  - 禁止指令冲排序，内存屏障
- mysql页锁是怎么用的
  - BDB引擎有页锁
- redis周期性的慢，是什么造成的
  - 周期性的进行数据持久化
  - 淘汰机制
- dubbo怎么样让调用远程服务跟调用本地服务一样的
  - Invoker 是 Dubbo 领域模型中非常重要的一个概念，是对远程调用的抽象，通过动态代理来屏蔽掉远程调用的一些细节  
    让调用远程服务跟调用本地服务一样的。无论是 consumer 还是 provider，Dubbo 都会给你生成代理，代理之间进行网络通信
- spi扩展机制在实际开发中的使用
  - 和厂商对接合规系统，合规数据有不同厂商提供。先定义通用接口，不同厂商对应不同实现，通过spi机制获取不同厂商的合规数据
- 实际开发中运用的设计模式
- T E K V E ？
  - ？ 表示不确定的 java 类型 
  - T (type) 表示具体的一个java类型 
  - K V (key value) 分别代表java键值中的Key Value 
  - E (element) 代表Element
- 设计模式
  - AbstractCommonExportHandler<T> implements CommonExportHandler
  - ProductPriceExportHandler extends AbstractCommonExportHandler<ProductPriceEo>
  - @Resource
    private Map<String, CommonExportHandler> commonExportHandlerMap;
  - 定义一个导出服务的接口，由一个抽象类来实现。这样抽象类只需实现一些共用的方法
  - 由具体业务执行器去继承抽象类，各自实现自己查询寻数据导出业务
  - 将执行注入到通用业务调用接口中，根据传入的参数获取对应的执行器进行导出操作
- dubbo延迟暴露
  - 如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。  
  我们在 Dubbo 2.6.5 版本中对服务延迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay > 0）服务的倒计时动作推迟到了 Spring 初始化完成后进行
- dubbo'负载均衡算法
  - Random LoadBalance
    - 随机，按权重设置随机概率。
    - 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。
  - RoundRobin LoadBalance
    - 轮询，按公约后的权重设置轮询比率。
    - 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。
  - LeastActive LoadBalance
    - 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
    - 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
#### 首汽
- springmvc 原理
- 根据请求自动生成接口（handlermaping）
- volatile syncronized区别
- jvm内存区域划分
- jmm
- 类加载过程
- redis空间类型
- redis数据类型
- 淘汰策略
- jvm调优
- 分库分表
- BEAN生命周期
- 循环依赖
  - 三级缓存，一级缓存存放完整的bean，二级缓存存放实例化完成还未进行属性填充的bean，正常二级缓存就可以解决循环依赖  
  ，三级缓存是为解决循环依赖并且有代理时，不打破bean生成的生命周期。如过A依赖B，B依赖A。B需要的A应该是代理的A。正常  
  代理对象的生成是基于后置处理器，是在被代理的对象初始化后期调用生成的，所以如果你提早代理了其实是违背了 Bean 定义的生命周期。  
    所以 Spring 先在一个三级缓存放置一个工厂，如果产生循环依赖，那么就调用这个工厂提早得到代理对象。如果没产生依赖，这个工  
  厂根本不会被调用，所以 Bean 的生命周期就是对的。
- 为什么是三级 
- springboot自动装配
- gc调优
#### 水滴
- mysql死锁
- redission续期
- volatile
- 解决死锁
- 单接口可靠性
- 限流降级
  - 是限制请求的并发
  - 请求的服务异常 或者超时 的一种策略 防止无用的请求
  - 一个是防止当前系统挂了导致不可用 一种是减少没必要的请求资源浪费
- 流量不大用限流吗
- mysql索引和锁的关系
- 聚集索引和二级索引的关系
