## 面试总结

#### 国美 
- java子线程中获取父线程的threadLocal中的值
  - InheritableThreadLocal,实现子线程获取父线程的变量信息，  
    如果允许new的线程继承当前线程的threadlocalMap，那么new的  
    线程会copy一份当前线程也就是父线程的inheritableThreadLocals 。  
    这儿也可以说明继承有两条件，new的线程允许继承(默认允许)，父线程的inheritableThreadLocals 不为null。
- 生产上线程池拒绝策略执行之后，抛出异常，如何处理的
  - submit 方法提交一个会抛出运行时异常的任务，捕不捕获异常都可以。
    - 无论如何都不会触发 dispatchUncaughtException 方法。因为 submit 方法提交，不论你捕获与否，源码里面都帮你捕获了
  - execute 方法提交一个会抛出运行时异常的任务，不捕获异常。
    - 如果不捕获异常，会触发 dispatchUncaughtException 方法，因为 runWorker 方法的源码里面虽然捕获了异常，但是又抛出去了
  - submit 或者 execute 提交，让线程池饱和之后抛出拒绝异常，代码没有捕获异常。
    - 和第二种其实是一样的。没有捕获，就会触发dispatchUncaughtException。
- 线程池的线程数根据什么设置的，比如是双核，如何设置
  - 如果是 CPU 密集型的，可以把核心线程数设置为核心数+1
    - 即使当计算（CPU）密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个“额外”的线程也能确保 CPU 的时钟周期不会被浪费。  
    备份线程
  - IO 密集型
    - 设置为 2*CPU 核心数
  - allowCoreThreadTimeOut设置为true允许回收核心线程，默认为false
  - prestartCoreThread启动所有的核心线程数
- 线程池如何去平衡插入和阻塞的、根据什么通知插入和阻塞
  - 
- 可重入锁是如何实现的
  - 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁  
  （前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞
  - 获取锁的时候会判断持有锁的线程是否为当前线程
  - 非重入是直接修改状态不去判断
- hashSet如何保证唯一
  - 底层实现为hashmap，key相同会覆盖
- HashMap解决哈希冲突一定会在链表上插入元素吗
  - 链表长度大于8且数组长度大于流64会转为红黑树
- 生产上初始堆的大小和最大堆的大小设置的值一样吗，为什么一样，或者为什么不一样
  - 一样。如果设置成不一样的话，虽然能动态申请内存，但是这种内存充分配会有系统开销
- volatile可见性失效的情况，举例说明
  - volatile修饰的变量会通过总线嗅探机制，保证变量被修改后，其他线程缓存行的变量副本失效  
  ，从新去主存读取。i++操作，非原子
  - 禁止指令冲排序，内存屏障
- mysql页锁是怎么用的
  - BDB引擎有页锁
- redis周期性的慢，是什么造成的
  - 周期性的进行数据持久化
  - 淘汰机制
- dubbo怎么样让调用远程服务跟调用本地服务一样的
  - Invoker 是 Dubbo 领域模型中非常重要的一个概念，是对远程调用的抽象，通过动态代理来屏蔽掉远程调用的一些细节  
    让调用远程服务跟调用本地服务一样的。无论是 consumer 还是 provider，Dubbo 都会给你生成代理，代理之间进行网络通信