## Spring-IOC  

#### 循环依赖
- Spring中A依赖B，B依赖A在初始化的时候就形成了循环依赖    
-![循环依赖!](/studyforbat/pic/loop_dependncy.png "循环依赖")
- 解决办法：三级缓存，如果沒有循环依赖的话，用不到二、三级缓存。如果有循环依赖没有aop也会用到三级缓存
  - 一级缓存：存放实例化、属性填充（调用populate()方法时进行）、初始化完成的bea 
  - 二级缓存：存放实例化完成的Bean，还未进行属性填充和初始化（早期对象）  
  - 三级缓存：存放封装了早期对象的函数式接口（ObjectFactory），在IOC后期的过程中，当Bean调用了
  构造函数时就会将早期对象封装成ObjectFactory，暴露在三级缓存中。spring的aop动态代理是在bean初始  
  化以后创建的，但是如果有循环依赖的话，无法等到初始化完成，因为此时已经完成了属性填充  
- 加载过程：
首先创建A，1.调用getsingleton（）：getsingleton（）从一级缓存中取，取到直接返回；取不到并且正在创建的话从二级缓存中取  
，有的话返回该bean，没有的话并且正在创建，则从三级缓存中取，取出来的话回调ObjectFactory的方法创建实例放入二级缓存   
，返回创建好的实例；2.如果getsingleton（）返回null，判断是否已经加入正在创建集合，没有的话加入，然后实例化、将早期实例封装成ObjectFactory  
暴露在三级缓存中。3.属性填充：调用getsingleton（）获取B，过程同上，当填充到B里边的A时，则能获取到三级缓存中创建的早期实例A进行填充并放入二级缓存，最后移除二  
级缓存中的B，将B填充到一级缓存，最后移除二、三级缓存中的B。4.递归结束将B填充到A的属性，如果二级缓存中存在A则将填充到一级缓存，最后移除二、三级缓存中的A，
- ![循环依赖!](/studyforbat/pic/loop-create.png "循环依赖")
- 两级缓存的意义
  - 将实例化后的BEAN与初始化完成的BEAN分开存储，同时利用同步锁防止多线程时获取到未初始化完成的BEAN
- 三级缓存的意义
  - 用于解耦，当循环依赖涉及到AOP时，将复杂的的逻辑抽离出来，减少程序的复杂性
- spring能解决构造函数的循环依赖问题吗？
  - 不能，循环依赖是在实例化后完成，而调用构造函数是尚未创建实例
- 多例BEAN能不能解决循环依赖？
  - 不能，多例模式下并未将实例放进缓存
  
#### spring监听器   接口方式和注解方式 实现原理：观察者模式（事件、监听器、事件发布）
- 单例Bean创建完毕刷新和关闭容器的时候都有相应的内置监听器， 实现SmartInitializingSingleton接口的类也会在bean创建完毕执行

#### spring AOP   面向切面编程思想利用动态代理实现。
- 配置方式演进过程 基于接口-> xml -> Aspectj注解
- 如果使用接口则使用的JDK动态代理，如果没有接口，则使用的cglib。AOP要依赖与IOC容器进行管理，只能增强的Bean的方法  
，如果没有注入到容器，无法利用AOP增强
- Aspectj提供了切点解析和匹配以及注解支持，属于静态织入，通过修改代码实现，织入时机可以使编译前、编译后、类加载的时候，  
他提供了Aop的完全解决方案。Spring Aop则是在容器启动的时候生成代理来实现，在方法调用上会增加栈的深度，性能不如Aspectj，  
用于企业级开发中普遍的Aop需求。Aspectj在运行前已经完成了织入，没有运行的额外开销。
- 将与主业务无关的逻辑抽离出来，减少耦合。利用动态代理对已有方法进行增强
- Aspect（切面）管理通知和切点，通知即为对方法的增强逻辑
- pointcut（切点）指定需要增强的方法
- 织入 将增强逻辑切入的指定法法中（利用动态代理）
- advisor 封装了advice（通知）和pointcut（切点）
- 注解方式aop：开启注解，定义pointcut指定增强的方法。通知定义增强（befor、after、around）
- 注解方式的Aop
  - advisor是在第一个bean后置处理器执行时生成，找到所有的Aspectj注解的类，将befor、after这些增强封装成advisor
  - createBrean时，bean初始化后，后置处理器调用时，拿到之前所有的advisor的pointcut调用match匹配判断是否生产成当前bean的代理类
  - 调用代理类时，将advisor转换为intercrptor，利用责任链的模式将所有的advisor递归调用一遍
- 如果有接口则会用jdk的动态代理，如果进行注解设置了并且没有接口则会使用cglib。有设置但有接口也会使用jdk动态代理
  - jdk动态代理需要实现接口，自己生成字节码文件，通过反射进行方法增强
  - cglib利用ASM组件生成多个字节码文件，通过继承，直接调用子类方法进行增强

#### spring声明式事务。
- ACID 原子性、一致性、隔离性、持久性
- 事务传播
- 使用事务：注解开启事务
- Aop的后置处理器的优先级高于事务后置处理器的优先级，会进行覆盖
- 事务的advisor是容器启动的时候内置的，里边封装了事务的属性源，用于解析Transactional注解，而springaop是自己手写表达式
- 匹配的时候 类的方法-> 父类方法 -> 接口方法 ->类上
- 事务生效：1.执行带有Transactional注解的方法 2.代理类执行责任链调用 3.判断是不是责任链最后一个，是的话执行具体方法 4.不是  
的话拿到之前解析的事务属性，开启事务，责任递归调用具体方法（操作数据库），异常回滚。执行完毕提交事务
- 融合事务，嵌套事务不提交，和外部事务一起提交
- 挂起事务（嵌套事务中出现），把嵌套事务最为顶层事务，把外层事务暂存
- 嵌套事务只会存一个connection
- -spring4 日志：jcl，jcl已经停止更新

#### spring MVC
- 早期：请求 -> JSP -> JAVA BEAN -> 数据源 jsp同时担任处理器和视图展示
- 演进：请求 -> serverlet（C）  -> JAVA BEAN（M） -> 数据源，然后处理器将数据返  
给jsp（V）。视图展示和处理器和视图展示
![](C:\appstore\jdproject\codeStudy\studyforbat\pic\01-Springmvc执行流程.png)
- 拦截器：springmvc容器启动的时候加载进去的
- spring ioc容器扫描的时候不回加载mvc的bean，mvc的容器是会加载spring的Bean

